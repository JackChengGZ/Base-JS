<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
<script type="application/javascript">
    /*
    * 执行上下文的生命周期
    *
    * 总的生命周期：创建->执行->出栈等待销毁
    * 1.创建阶段：(主要)
    *   创建作用域链(Scope Chain)
    *   创建变量对象(AO和VO):首先初始化函数的参数arguments,初始化函数声明,初始化变量
    *   (undefined).函数的优先级要高于变量，如果变量和函数重名，变量会被忽略
    *        .创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。
    *        .扫描上下文的函数声明(而非函数表达式)：
    *            .为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字
    *            其有一个指向函数在内存中的引用。
    *            如果函数的名字已经存在，引用指针将被重写
    *        .扫描上下文的变量声明：
    *            .为发现的每个变量声明，在变量对象上创建一个属性——确切的说是变量的名字，
    *             并且将变量值得初始化为undefined
    *            .如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描
    *        .求出上下文内部this的值
    * 2.执行阶段：
    *       .执行变量赋值、代码执行
    * 3.回收阶段：
    *       .执行上下文出栈等待虚拟机回收执行上下文
    *
    *
    * */

    //变量声明
    var a1=19,
        a2=20,
        a3='sss',
        b1={name:'laoma'};
    //函数调用
    a1=f1(a1,a2);//函数先调用后声明，因为声明提升
    //函数声明
    function f1(a,b){
        //f1函数的执行上下文EC
        //第一步：扫描参数 a=19,b=20
        //第二部：扫描函数函数声明  f2=function(){}
        //第三部：扫描变量声明  t=undefined  m=undefined  i=undefined
        var t= 0,m=10;
        for(var i=0;i<a;i++){
            console.log(i);
        }
        function f2(){
            console.log(f2);
        }
        return a+b;
    }

</script>
</html>